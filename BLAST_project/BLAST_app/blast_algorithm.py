# -*- coding: utf-8 -*-
"""ABIN_A2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NTi20BZrYbNJq5qKux2fTF8CZUydbNHv

# Header Files
"""

# Add Imports Here
import os
import sys
from nltk import edit_distance
import numpy as np
import itertools
import time
from Bio import SeqIO
from numpy.core.fromnumeric import sort


"""# Initial values"""

# All Parameters Here
KMER_LENGTH = 11
MATCH = 1
MISMATCH = -1
GAPS = -1
HSSP = 1 #Maximum Difference
EXTENSION_THRESHOLD = 1
NUMBER_OF_BASES = 4  # Nucleotides
BASE_VALUE_MAP = {"A": 0, "C": 1, "G": 2, "T": 3}
NUCLEOTIDES = ["A","T","C","G"]
ALL_NUCLEOTIDES = ["A","T","C","G"]
SCORE_THRESHOLD = 1

# Following values are from Karlin-Altschul statistics
# For match value 1 and mismatch value -1
lambda_ = 1.09861
K = 0.333333
H = 0.549306

"""# Class"""

# All Classes Here
class kmer_info(object):
    def __init__(self, kmer, positions, key):
        self.kmer = kmer
        self.positions = positions
        self.key = key

    def __str__(self) -> str:
        return "Kmer: {}\tpositions: {}\tkey: {}".format(
            self.kmer, " ".join(map(str, self.positions)), self.key
        )

    @staticmethod
    def comparatorForKeyToSort(obj) -> int:
        return obj.key


class node:
    def __init__(self, data: kmer_info):
        self.data = data
        self.left = None
        self.right = None

    def __str__(self) -> str:
        return str(self.data)


class bst:
    def __init__(self):
        self.head = None

class alignments:
    def __init__(self, DB, seq1, seq2, start, end, edist):
        self.DATABASE_SEQUENCE_INFO = DB;   #FOR Multiple Sequence.
        self.LOCUS_START = start;              #Needs to be filled.
        self.LOCUS_END = end;                #Needs to be filled.
        self.seq1 = seq1
        self.seq2 = seq2
        self.bit_score = 0
        self.score = 0
        self.pscore = 0
        self.escore = 0
        self.edist = edist
    
    def __lt__(self, obj):
        return self.pscore < obj.pscore
        # return self.score < obj.score

    def __eq__(self, obj):
        return self.pscore == obj.pscore
        # return self.score == obj.score
    
    def __str__(self):
        myString = "P-Score: {}   E-value: {}\nScore: {}    Bit-Score: {}\n".format(self.pscore, self.escore, self.score, self.bit_score)
        myString += self.seq1+"\n"
        myString += self.seq2+"\n"
        myString += "DB ID: "+str(self.DATABASE_SEQUENCE_INFO)+"\n"
        myString += "Alignment starts : end at: "+str(self.LOCUS_START+1)+" : "+str(self.LOCUS_END+1)+"\n"

        return myString

"""# Functions"""

# All Helper Functions Here

def generateKmers(seq, KMER_LENGTH)->list:
    kmers = list()
    for i in range(len(seq)-KMER_LENGTH+1):
        kmers.append(seq[i:i+KMER_LENGTH])
    return kmers

def introduce_mutation_at_pos(Lmer, pos, Nucleotides) -> list:
    all_possible_mutation_at_pos = []
    for i in range(len(Nucleotides)):
        if(Lmer[pos] == Nucleotides[i]):
            continue
        else:
            mutated = Lmer[0:pos] + Nucleotides[i] + Lmer[pos+1:]
            all_possible_mutation_at_pos.append(mutated)
    return all_possible_mutation_at_pos

def allPossibleMutationsAtDistOne(seq: str, NUCLEOTIDES: list) -> set:
    allPossibleMutations = set()
    for mutation_pos in range(len(seq)):
        allPossibleMutations.update(set(introduce_mutation_at_pos(seq, mutation_pos, NUCLEOTIDES)))
    return allPossibleMutations

def allAlternativeKmersLessThanHSSP(seq: str, HSSP_SCORE: int, NUCLEOTIDES: list)->set:
    global_space = set()
    local_space = set()
    local_space.add(seq)
    for i in range(0, HSSP_SCORE):
        temp = set()
        for j in local_space:
            temp.update(allPossibleMutationsAtDistOne(j, NUCLEOTIDES))
        local_space = temp
        global_space.update(local_space)
    global_space.update(local_space)
    return global_space

def getAllAlternativeKeysForKmersSatisfyingHSSP(seq: str, HSSP_SCORE: int, NUCLEOTIDES: list, BASE_VALUE_MAP: dict)->list:
    allKmersKeySatisfyingHSSPThreshold = []
    alternativeKmers = allAlternativeKmersLessThanHSSP(seq, HSSP_SCORE, NUCLEOTIDES)
    alternativeKmers.add(seq)
    for kmer in alternativeKmers:
        allKmersKeySatisfyingHSSPThreshold.append(getKey(kmer, BASE_VALUE_MAP))
    return allKmersKeySatisfyingHSSPThreshold

def getAllHSSP(queryKmers: list, HSSP_SCORE: int, NUCLEOTIDES: list, BASE_VALUE_MAP: dict) -> dict:
    allHSSPKmersKey = dict()
    for i in range(len(queryKmers)):
        allHSSPKmersKey[i+1] = getAllAlternativeKeysForKmersSatisfyingHSSP(queryKmers[i], HSSP_SCORE, NUCLEOTIDES, BASE_VALUE_MAP)
    return allHSSPKmersKey

def bstSearch(root: node, key: int)->node:
    if(root==None):
        return None
    elif(key<root.data.key):
        return bstSearch(root.left, key)
    elif(key>root.data.key):
        return bstSearch(root.right, key)
    else:
        return root

def inOrder(head: node) -> None:
    if head != None:
        inOrder(head.left)
        print(head)
        inOrder(head.right)


def convertArraytoBST(arr: kmer_info, left: int, right: int, head: node) -> bst:
    if left != right:
        mid = left + (right - left) // 2
        head = node(arr[mid])
        head.left = convertArraytoBST(arr, left, mid, head.left)
        head.right = convertArraytoBST(arr, mid + 1, right, head.right)
        return head
    return None


def getKey(Sequence: str, BASE_VALUE_MAP: dict) -> int:
    s = Sequence[::-1]
    sequenceKey = 0
    for i in range(len(s)):
        sequenceKey += BASE_VALUE_MAP[s[i]] * (len(BASE_VALUE_MAP) ** i)
    return sequenceKey


def getKmerWithPositions(sequence: str, kmer_len: int) -> dict:
    myMapToStoreKmerPositions = {}
    for i in range(len(sequence) - kmer_len + 1):
        currKmer = sequence[i : i + kmer_len]
        if currKmer not in myMapToStoreKmerPositions:
            myMapToStoreKmerPositions[currKmer] = [i]
        else:
            myMapToStoreKmerPositions[currKmer].append(i)
    return myMapToStoreKmerPositions


def getKeysForAllKmers( myMapContainingKmerPositions: dict, BASE_VALUE_MAP: dict) -> list:
    preProcessedInfo = []
    for kmer in myMapContainingKmerPositions:
        preProcessedInfo.append(
            kmer_info(
                kmer, myMapContainingKmerPositions[kmer], getKey(kmer, BASE_VALUE_MAP)
            )
        )
    return preProcessedInfo

def searchHSSPinBST(allHSSPKmersKey: dict, head: node):
    matchesFound={}
    for i in range(1,1+len(allHSSPKmersKey)):
        matchesFound[i]=[]
    for i in range(1,1+len(allHSSPKmersKey)):
        for j in allHSSPKmersKey[i]:
            x=bstSearch(head,j)
            if(x!=None):
                for k in x.data.positions:
                    matchesFound[i].append(k)
    for i in range(1,len(matchesFound)+1):
        for j in range(len(matchesFound[i])):
            matchesFound[i][j]+=1 ## Make the starting positions 1-indexed    
    return matchesFound    

def createMatrix(query: str,database: str):
    matrix=[]
    for i in range(len(query)+1):
        x=[0]*(len(database)+1)
        matrix.append(x)
    for i in range(len(query)):
        for j in range(len(database)):
            if(query[i]==database[j]):
                matrix[i+1][j+1]=1
    return matrix

def seeding(matrix: list,startPos: dict, query: str,database: str):
    #For Kmer of length qlen
    qlen=len(query)
    dblen=len(database)
    for i in range(1,len(startPos)+1):
        for j in range(len(startPos[i])):
            seed_len=min(KMER_LENGTH,qlen-i+1,dblen-startPos[i][j]+1)
            if(matrix[i-1][startPos[i][j]-1]==0):
                for k in range(1,seed_len):
                    if(query[i+k-1]==database[startPos[i][j]+k-1]):
                        matrix[i+k][startPos[i][j]+k]=matrix[i+k-1][startPos[i][j]+k-1]+1 ### For Match Only
                    else:
                        matrix[i+k][startPos[i][j]+k]=max(matrix[i+k-1][startPos[i][j]+k-1]-1,0) ### For Mis-Match in seed  S
                    ####GAPS####
                    if(query[i+k-2]!=database[startPos[i][j]+k-1]):
                        matrix[i+k-1][startPos[i][j]+k]=max(0,matrix[i+k-1][startPos[i][j]+k-1]-1)
                    if(query[i+k-1]!=database[startPos[i][j]+k-2]):
                        matrix[i+k][startPos[i][j]+k-1]=max(0,matrix[i+k-1][startPos[i][j]+k-1]-1)
            elif(matrix[i-1][startPos[i][j]-1]>0):
                for k in range(0,seed_len):
                    if(query[i+k-1]==database[startPos[i][j]+k-1]):
                        matrix[i+k][startPos[i][j]+k]=matrix[i+k-1][startPos[i][j]+k-1]+1 ### For Match Only
                    else:
                        matrix[i+k][startPos[i][j]+k]=max(matrix[i+k-1][startPos[i][j]+k-1]-1,0) ### For Mis-Match in seed
                    ####GAPS####
                    if(query[i+k-2]!=database[startPos[i][j]+k-1]):
                        matrix[i+k-1][startPos[i][j]+k]=max(0,matrix[i+k-1][startPos[i][j]+k-1]-1)
                    if(query[i+k-1]!=database[startPos[i][j]+k-2]):
                        matrix[i+k][startPos[i][j]+k-1]=max(0,matrix[i+k-1][startPos[i][j]+k-1]-1)
    return matrix


def effSeeding(matrix: list,startPos: dict, query: str,database: str):
  #For Kmer of length qlen
    qlen=len(query)
    dblen=len(database)
    for i in range(1,len(startPos)+1):
        for j in range(len(startPos[i])):
            seed_len=min(KMER_LENGTH,qlen-i+1,dblen-startPos[i][j]+1)
            loopStartPos = 1 if (matrix[i-1][startPos[i][j]-1]==0) else 0 #The only change
            for k in range(loopStartPos,seed_len):
                if(query[i+k-1]==database[startPos[i][j]+k-1]):
                    matrix[i+k][startPos[i][j]+k]=matrix[i+k-1][startPos[i][j]+k-1]+1 ### For Match Only
                else:
                    matrix[i+k][startPos[i][j]+k]=max(matrix[i+k-1][startPos[i][j]+k-1]-1,0) ### For Mis-Match in seed  S
                ####GAPS####
                if(query[i+k-2]!=database[startPos[i][j]+k-1]):
                    matrix[i+k-1][startPos[i][j]+k]=max(0,matrix[i+k-1][startPos[i][j]+k-1]-1)
                if(query[i+k-1]!=database[startPos[i][j]+k-2]):
                    matrix[i+k][startPos[i][j]+k-1]=max(0,matrix[i+k-1][startPos[i][j]+k-1]-1)
    return matrix

#P score calculation (significance calculation)
#Calculated using probablity sum of score of all possible query seq
def p_score(matches: list) -> list:

  P_value = list()
  for query_seq,database_seq in matches:
    current_score = (edit_distance(query_seq, database_seq))
    all_matches = list(map(''.join, itertools.product(ALL_NUCLEOTIDES, repeat = len(query_seq))))
    score_list = np.array(list(map(lambda x: edit_distance(x,database_seq), all_matches)))
    P_value.append(score_list[score_list<=current_score].shape[0]/score_list.shape[0])
  
  return P_value


#Significance significance calculation by p,e value and bit score
#Calculated using Karlin-Altschul statistics
#Runtime approx 0.002 sec for 17K alignments
def Statistical_Significance(aliged_seq: list, query_length: int, database_length: int) -> list:

  n = query_length       #length of query sequence
  m = database_length    #length of query sequence

  for alignment in aliged_seq:
    mismatch_positions = (edit_distance(alignment.seq1, alignment.seq2))                        #mismatch positions
    query_length = len(alignment.seq1)
    alignment.score = (query_length-mismatch_positions)*MATCH + (mismatch_positions)*MISMATCH   #Score with match and mismatch 
    alignment.bit_score = ((lambda_*alignment.score) - np.log(K))/np.log(2)                     #Bit score
    alignment.pscore = np.power(2,-1*alignment.bit_score)                                       #P value calculation
    alignment.escore = m*n*alignment.pscore                                                     #E value calculation

# ungapped BLAST
def align_combine(DB, Query, matchind, threshold):
  # method to combine 2 matches if they are within a threshold to get even larger alignment
    finalaligns = set()
    for i in range(len(matchind)):
      finalaligns.add((matchind[i][0],matchind[i][1],matchind[i][2],matchind[i][3]))
    matches2 = []
    matches2ind = []
    for i in finalaligns:
      matches2.append([DB[i[0]:i[1]+1], Query[i[2]:i[3]+1]])
      matches2ind.append((i[0],i[1]))
    return matches2,matches2ind

def extension(DB, Query, x1, x2, y1, y2, backscore, fwdscore, threshold):
  # extension in backward direction
    while(True):
        if(x1<0 or y1<0):
            break
        if(Query[y1]==DB[x1]):
            backscore+=1
        else:
            backscore-=1
        x1-=1
        y1-=1
        
        if(backscore<threshold):
            break
    # extension in forward direction
    while(True):
        if(x2>=len(DB) or y2>=len(Query)):
            break
        if(Query[y2]==DB[x2]):
            fwdscore+=1
        else:
            fwdscore-=1
        x2+=1
        y2+=1
        if(fwdscore<threshold):
            break
    return x1,x2,y1,y2

def BLAST(Query: str, DB: str, threshold: int, startPositions: dict, KMER_LENGTH: int):
    matchind = []
    for i in startPositions:
        for j in startPositions[i]:
            y = i-1
            x = j-1
            currscore = 0
            for k in range(KMER_LENGTH):
                if(Query[y]==DB[x]):
                  if(k==0):
                    backscore = 1
                  else:
                    backscore = 0
                  currscore+=1
                else:
                  currscore-=1
                x+=1
                y+=1
            fwdscore = currscore

            x1,x2,y1,y2 = extension(DB, Query, x-4, x, y-4, y, backscore, fwdscore, threshold)
            matchind.append([x1+1,x2-1,y1+1,y2-1])

    matches, indices = align_combine(DB, Query, matchind, threshold)
    return matches, indices

"""# Driver code"""

def BLAST_DRIVER(Query: str, path_to_database_dir: str):

  # Database Sequence insertion
  ### Add all covid strains to databases
  DB_SEQUENCES = list()
  DB_SEQUENCES_INFO = list()

  module_dir = os.path.dirname(__file__)
  file_path = os.path.join(module_dir, path_to_database_dir)
  with open(file_path, "r") as handle:
      for record in SeqIO.parse(handle, "fasta"):
          DB_SEQUENCES.append(str(record.seq).replace('N',''))
          DB_SEQUENCES_INFO.append(str(record.id))
  #To store all the alignment
  align = []

  for j in range(0, len(DB_SEQUENCES)):

      DB = DB_SEQUENCES[j]

      # Generating Kmers of database along with positions, storing in hashmap KMER: [positions]
      myMap = getKmerWithPositions(DB, KMER_LENGTH)

      # generate keys for all kmers
      preProcessed = getKeysForAllKmers(myMap, BASE_VALUE_MAP)

      # Sort using key 
      preProcessed = sorted(preProcessed, key=kmer_info.comparatorForKeyToSort)

      # Create Binary Search Tree of database kmers on key
      searchTree = bst()
      searchTree.head = convertArraytoBST(preProcessed, 0, len(preProcessed), searchTree.head)

      # inOrder(searchTree.head) # Printing BST inorder traversal

      # Creating Kmers of The query Sequence
      queryKmers = generateKmers(Query, KMER_LENGTH)

      #Get All HSSP Kmers key
      allHSSP= getAllHSSP(queryKmers, HSSP, NUCLEOTIDES, BASE_VALUE_MAP)

      #Search All HSSP  in Bst and return the ones found
      startPositions=searchHSSPinBST(allHSSP,searchTree.head)

      ###Seeding and Extending using SW-Algorithm###
      matches, match_indices = BLAST(Query, DB, EXTENSION_THRESHOLD, startPositions, KMER_LENGTH)

      # Store all alignment class in the list
      for index, seq in enumerate(matches):
        align.append(alignments(DB_SEQUENCES_INFO[j], seq[0], seq[1], match_indices[index][0], match_indices[index][1], edit_distance(seq[0],seq[1])))

  #To calculate all significance score of all alignments
  Statistical_Significance(align, len(Query), np.sum([len(i) for i in DB_SEQUENCES]))

  #To give only top 10 alignment sorted with p-score
  align.sort()
  with open(os.path.join(module_dir, "output.txt"), 'w') as sys.stdout:
      print(*sorted(align)[:10], sep="\n")
  return align[:10]
#   sorted_aligned = dict()
#   sorted_aligned['query'] = []
#   sorted_aligned['database_seq'] = []
#   sorted_aligned['pscore'] = []
#   sorted_aligned = []
#   for i in align[:10]:
    # sorted_aligned['query'].append(i.seq1)
    # sorted_aligned['database_seq'].append(i.seq2)
    # sorted_aligned['pscore'].append(i.pscore)
    #   sorted_aligned.append([i.seq1, i.seq2, i.pscore, i.LOCUS_START, i.LOCUS_END, i.DATABASE_SEQUENCE_INFO, i.bit_score])
#   return sorted_aligned

        #   self.DATABASE_SEQUENCE_INFO = DB;   #FOR Multiple Sequence.
        # self.LOCUS_START = start;              #Needs to be filled.
        # self.LOCUS_END = end;                #Needs to be filled.
        # self.seq1 = seq1
        # self.seq2 = seq2
        # self.bit_score = 0
        # self.score = 0
        # self.pscore = 0
        # self.escore = 0
        # self.edist = edist



# Query_sequence = "GCCTATACAGTTGAACTCGGTACAGAAGTAAATGAGTTCGCCTGTGTTGTGGCAGATGCTGTCATAAAAACTTTGCAACCAGTATCTGAATTACTTACACCACTGGGCATTGATTTAGATGAGTGGAGTATGGCTACATACTACTTATTTGATGAGTCTGGTGAGTTTAAATTGGCTTC"

# path_to_database = "sequence.fasta"

# BLAST_DRIVER(Query_sequence, path_to_database)